/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/** Join type */
export const enum JoinType {
  /** Inner Join */
  Inner = 0,
  /** Left Join */
  Left = 1,
  /** Right Join */
  Right = 2,
  /** Full Join */
  Full = 3,
  /** Left Semi Join */
  LeftSemi = 4,
  /** Right Semi Join */
  RightSemi = 5,
  /** Left Anti Join */
  LeftAnti = 6,
  /** Right Anti Join */
  RightAnti = 7
}
/**
 * Create a column expression based on a qualified or unqualified column name
 *
 * example:
 * ```
 * const c = col('my_column');
 * ```
 */
export function col(name: string): Expr
/** Return a new expression `left <op> right` */
export function binaryExpr(left: Expr, op: Operator, right: Expr): Expr
/** Return a new expression `left <op> right` */
export function and(left: Expr, right: Expr): Expr
/** Return a new expression with a logical OR */
export function or(left: Expr, right: Expr): Expr
/** Create an expression to represent the min() aggregate function */
export function min(expr: Expr): Expr
/** Create an expression to represent the max() aggregate function */
export function max(expr: Expr): Expr
/** Create an expression to represent the sum() aggregate function */
export function sum(expr: Expr): Expr
/** Create an expression to represent the avg() aggregate function */
export function avg(expr: Expr): Expr
/** Create an expression to represent the count() aggregate function */
export function count(expr: Expr): Expr
/** Create an expression to represent the count(distinct) aggregate function */
export function countDistinct(expr: Expr): Expr
/** Create an in_list expression */
export function inList(expr: Expr, list: Array<Expr>, negated: boolean): Expr
/** Concatenates the text representations of all the arguments. NULL arguments are ignored. */
export function concat(args: Array<Expr>): Expr
/**
 * Concatenates all but the first argument, with separators.
 * The first argument is used as the separator.
 * NULL arguments in `values` are ignored.
 */
export function concatWs(sep: Expr, values: Array<Expr>): Expr
/** Returns a random value in the range 0.0 <= x < 1.0 */
export function random(): Expr
/**
 * Returns the approximate number of distinct input values.
 * This function provides an approximation of count(DISTINCT x).
 * Zero is returned if all input values are null.
 * This function should produce a standard error of 0.81%,
 * which is the standard deviation of the (approximately normal)
 * error distribution over all possible sets.
 * It does not guarantee an upper bound on the error for any specific input set.
 */
export function approxDistinct(expr: Expr): Expr
/** Calculate an approximation of the median for `expr`. */
export function approxMedian(expr: Expr): Expr
/** Calculate an approximation of the specified `percentile` for `expr`. */
export function approxPercentileCont(expr: Expr, percentile: Expr): Expr
/** Calculate an approximation of the specified `percentile` for `expr` and `weight_expr`. */
export function approxPercentileContWithWeight(expr: Expr, weightExpr: Expr, percentile: Expr): Expr
/** Create a grouping set */
export function groupingSet(exprs: Array<Array<Expr>>): Expr
/** Create a grouping set for all combination of `exprs` */
export function cube(exprs: Array<Expr>): Expr
/** Create a grouping set for rollup */
export function rollup(exprs: Array<Expr>): Expr
/** Create is null expression */
export function isNull(expr: Expr): Expr
/** Create is true expression */
export function isTrue(expr: Expr): Expr
/** Create is not true expression */
export function isNotTrue(expr: Expr): Expr
/** Create is false expression */
export function isFalse(expr: Expr): Expr
/** Create is not false expression */
export function isNotFalse(expr: Expr): Expr
/** Create is unknown expression */
export function isUnknown(expr: Expr): Expr
/** Create is not unknown expression */
export function isNotUnknown(expr: Expr): Expr
/** Operators applied to expressions */
export const enum Operator {
  /** Expressions are equal */
  Eq = 0,
  /** Expressions are not equal */
  NotEq = 1,
  /** Left side is smaller than right side */
  Lt = 2,
  /** Left side is smaller or equal to right side */
  LtEq = 3,
  /** Left side is greater than right side */
  Gt = 4,
  /** Left side is greater or equal to right side */
  GtEq = 5,
  /** Addition */
  Plus = 6,
  /** Subtraction */
  Minus = 7,
  /** Multiplication operator, like `*` */
  Multiply = 8,
  /** Division operator, like `/` */
  Divide = 9,
  /** Remainder operator, like `%` */
  Modulo = 10,
  /** Logical AND, like `&&` */
  And = 11,
  /** Logical OR, like `||` */
  Or = 12,
  /** IS DISTINCT FROM */
  IsDistinctFrom = 13,
  /** IS NOT DISTINCT FROM */
  IsNotDistinctFrom = 14,
  /** Case sensitive regex match */
  RegexMatch = 15,
  /** Case insensitive regex match */
  RegexIMatch = 16,
  /** Case sensitive regex not match */
  RegexNotMatch = 17,
  /** Case insensitive regex not match */
  RegexNotIMatch = 18,
  /** Bitwise and, like `&` */
  BitwiseAnd = 19,
  /** Bitwise or, like `|` */
  BitwiseOr = 20,
  /** Bitwise xor, like `#` */
  BitwiseXor = 21,
  /** Bitwise right, like `>>` */
  BitwiseShiftRight = 22,
  /** Bitwise left, like `<<` */
  BitwiseShiftLeft = 23,
  /** String concat */
  StringConcat = 24
}
export class DataFrame {
  /** Clone the current `DataFrame` and return a new `DataFrame` instance. */
  clone(): DataFrame
  /**
   * Filter the DataFrame by column. Returns a new DataFrame only containing the
   * specified columns.
   *
   * ```
   * import { SessionContext } from '@napi-rs/datafusion';
   * const ctx = new SessionContext();
   * const df = await ctx.readCsv('tests/data/example.csv');
   * df.selectColumns(&["a", "b"])?;
   * ```
   */
  selectColumns(columns: Array<string>): this
  /**
   * Create a projection based on arbitrary expressions.
   *
   * ```
   * import { SessionContext } from '@napi-rs/datafusion';
   * const ctx = new SessionContext();
   * const df = await ctx.readCsv('tests/data/example.csv');
   * df.select([col("a") * col("b"), col("c")]);
   * ```
   */
  select(exprList: Array<Expr>): this
  /** Filter a DataFrame to only include rows that match the specified filter expression. */
  filter(expr: Expr): this
  /** Perform an aggregate query with optional grouping expressions. */
  aggregate(groupExpr: Array<Expr>, aggrExpr: Array<Expr>): this
  /**
   * Limit the number of rows returned from this DataFrame.
   *
   * `skip` - Number of rows to skip before fetch any row
   *
   * `fetch` - Maximum number of rows to fetch, after skipping `skip` rows.
   * ```
   * import { SessionContext } from '@napi-rs/datafusion';
   * const ctx = new SessionContext();
   * const df = await ctx.readCsv('tests/data/example.csv');
   * df.limit(0, Some(100));
   * ```
   */
  limit(skip: number, fetch?: number | undefined | null): this
  /**
   * Calculate the union of two [`DataFrame`]s, preserving duplicate rows.The
   * two [`DataFrame`]s must have exactly the same schema
   *
   * ```
   * import { SessionContext } from '@napi-rs/datafusion';
   * const ctx = new SessionContext();
   * const df = await ctx.readCsv('tests/data/example.csv');
   * const d2 = df.clone();
   * df.union(d2);
   * ```
   */
  union(dataframe: DataFrame): this
  /**
   * Calculate the distinct union of two [`DataFrame`]s.  The
   * two [`DataFrame`]s must have exactly the same schema
   *
   * ```
   * import { SessionContext } from '@napi-rs/datafusion';
   * const ctx = new SessionContext();
   * const df = await ctx.readCsv('tests/data/example.csv');
   * df.distinct();
   * ```
   */
  unionDistinct(dataframe: DataFrame): this
  /**
   * Filter out duplicate rows
   *
   * ```
   * import { SessionContext } from '@napi-rs/datafusion';
   * const ctx = new SessionContext();
   * const df = await ctx.readCsv('tests/data/example.csv');
   * df.distinct(d2);
   * ```
   */
  distinct(): this
  /**
   * Sort the DataFrame by the specified sorting expressions. Any expression can be turned into
   * a sort expression by calling its [sort](../logical_plan/enum.Expr.html#method.sort) method.
   *
   * ```
   * import { SessionContext } from '@napi-rs/datafusion';
   * const ctx = new SessionContext();
   * const df = await ctx.readCsv('tests/data/example.csv');
   * df.sort([col('a').sort(true, true), col('b').sort(false, false)]);
   * ```
   */
  sort(expr: Array<Expr>): this
  /**
   * Print results.
   *
   * ```
   * import { SessionContext } from '@napi-rs/datafusion'
   *
   * const ctx = new SessionContext();
   * const df = await ctx.readCsv('tests/data/example.csv');
   * await df.show();
   * ```
   */
  show(): Promise<void>
}
export class Expr {
  /** Create a literal expression */
  static lit(value: string): Expr
  /** Return `self AS name` alias expression */
  alias(name: string): this
  /** Return `self <= other` */
  ltEq(other: Expr): this
  /** Return `self && other` */
  and(other: Expr): this
  /** Return `self || other` */
  or(other: Expr): this
  /** Return `!self` */
  not(): this
  /**
   * Calculate the modulus of two expressions.
   * Return `self % other`
   */
  modulus(other: Expr): this
  /** Return `self LIKE other` */
  like(other: Expr): this
  /** Return `self NOT LIKE other` */
  notLike(other: Expr): this
  /** Return `self ILIKE other` */
  ilike(other: Expr): this
  /** Return `self NOT ILIKE other` */
  notIlike(other: Expr): this
  /** Remove an alias from an expression if one exists. */
  unalias(): this
  /**
   * Return `self IN <list>` if `negated` is false, otherwise
   * return `self NOT IN <list>`.a
   */
  inList(list: Array<Expr>, negated: boolean): this
  /** Return `IsNull(Box(self)) */
  isNull(): this
  /** Return `IsNotNull(Box(self)) */
  isNotNull(): this
  /**
   * Create a sort expression from an existing expression.
   *
   * ```
   * const sortExpr = col('foo').sort(true, true); // SORT ASC NULLS_FIRST
   * ```
   */
  sort(asc: boolean, nullsFirst: boolean): this
  /** Return `IsTrue(Box(self))` */
  isTrue(): this
  /** Return `IsNotTrue(Box(self))` */
  isNotTrue(): this
  /** Return `IsFalse(Box(self))` */
  isFalse(): this
  /** Return `IsNotFalse(Box(self))` */
  isNotFalse(): this
  /** Return `IsUnknown(Box(self))` */
  isUnknown(): this
  /** Return `IsNotUnknown(Box(self))` */
  isNotUnknown(): this
  /** Clone the `Expr` and return the new `Expr` instance. */
  clone(): Expr
}
export class SessionContext {
  constructor()
  /** Create `SessionContext` from an execution config with config options read from the environment */
  static withConfigEnv(): SessionContext
  /**
   * Creates a [`DataFrame`] that will execute a SQL query.
   *
   * Note: This api implements DDL such as `CREATE TABLE` and `CREATE VIEW` with in memory
   * default implementations.
   */
  sql(sql: string): Promise<DataFrame>
  /** Creates a [`DataFrame`] for reading a CSV data source. */
  readCsv(path: string): Promise<DataFrame>
}
